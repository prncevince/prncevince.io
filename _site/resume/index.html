<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Vincent Clemson’s Rèsumè" />






<meta name="description" content="Vincent Clemson’s Rèsumè">

<script id="pandoc-meta" type="application/json">
{"include-after":"<div class=\"page2-end\">\n<p><a href=\"https://github.com/prncevince/borders\" target=\"_blank\">\n<img src=\"./assets/img/map-linear.png\">\n</a></p>\n</div>","knit":"pagedown::chrome_print","newpage_html_class":"page-break-after","output":{"pagedown::html_paged":{"css":["assets/css/style.css","assets/css/fonts.css"],"number_sections":false,"template":"assets/html/paged.html"}},"title":"Vincent Clemson’s Rèsumè"}
</script>

<title>Vincent Clemson’s Rèsumè</title>


<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();


	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;


	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {

				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {

				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page
			this.pageLastString;

		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();


				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {


			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}


			for (let name of Object.keys(this.stringSetSelectors)) {

				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;

					});

					/* FIRST */

					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";

				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);


			}
		}


	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}

							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>




<style type="text/css">
@page {
size: letter;

margin: 0.25in 0.25in 0.5in 0.25in;
@bottom-right {
content: counter(page);
}
@bottom-center {
content: element(footerRunning);
}
}
.footer {
position: running(footerRunning);
}


.top {
display: grid;
grid-template-columns: 1fr 1fr 1fr;
}
.linkedin, .site {
text-align: center;
}
.email, .twitter {
text-align: right;
}

.pagedjs_page_content > div {

position: absolute; }
.main {
display: grid;


grid-template-rows: 1fr;
grid-template-columns: 50% 50%;
}
.section.level1 {
grid-column: 1 / 3;
grid-row: 1 / 2;

}
div.page2-end {
grid-row: 2 / 3;
grid-column: 2;
text-align: center;
}

div.page2-end img {
width: 91%;
}
.footnotes {
grid-row: 2 / 3;
grid-column: 1 / 2;
font-size: 90%;
}

.pagedjs_margin-bottom-center > .pagedjs_margin-content {
padding-top: 10px;
font-size: 10px;
}
.pagedjs_left_page .pagedjs_margin-bottom {
grid-template-columns: .85fr 1.15fr 1fr !important;
}
.pagedjs_left_page .pagedjs_margin-bottom-center > .pagedjs_margin-content {
text-align: left;
}
div.education > h2 {
background-image: url(data:image/png;base64,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);
background-repeat: no-repeat;
background-position: 58% 75%;
background-size: 30px;
padding-top: 4px;
}
.top a {
color: black !important;
text-decoration: none;
}
a:not(.footnote-ref) {
color: #00A3E2;
}
.top .cell a {
background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABMCAYAAAD6BTBNAAAAAXNSR0IArs4c6QAAAHhlWElmTU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAIdpAAQAAAABAAAATgAAAAAAAACQAAAAAQAAAJAAAAABAAOgAQADAAAAAQABAACgAgAEAAAAAQAAAFCgAwAEAAAAAQAAAEwAAAAARn2ObQAAAAlwSFlzAAAWJQAAFiUBSVIk8AAAA7VJREFUeAHtnDmPFDEQhbnvMwCBEGghBiKOnwASIkQCJH4dISkxOYcIgBChTTgEAbc4xPU+LT3MjrY97S7b7EqvpLfdO+1ylb8ue3oC97p1NhMwgTVMYH3h3Lerv4PSaWlBwn4vHbL+9uUV6WtRGTySXktfpCK2qUgv/zrZr9NT0mXprMSAf0lDbYMaohRA+svtk/7uS+TzUFq1AA8ruXPSGQmQDPSnlDIGxQDRlr9HHXqN9t8ljp1vb2Nd2ChxU2j7SnopvZCKWOkK3KasqMJ9EomjzdIQ+6FGT6VnEoBWMgCfkI5LubmTE7mRYzHLTWJeYCB8lfoA9Pnj90a6Ld2U3ktdVep0Um17dX5DuiodkHLyJydyI1Yxy0kgJyjTJcdozwCBSBV+lFay3fqQNrQdE2OlPkOf1QJI9eQYaxTT85jEGgpAPps21lMA0oa2s9f1UdJyc0p21l2sBbDrf+iRtfKQdE26KFFhAJu2DjLr2B6pCpDpgEPOWwAEBED4Nk5NOwDtkljnUkY/PIbMAp72AS43ZUylTvcz97wFQBbu59IHqVu7UtXDtb7r3IDUTeAavoCjSo9IO6Rq1gIgT/63pCfSW4kKojpSlgKY8uv6ZpqflK5LC1I1awGQR5K70h3pU7WRLO+YpeCzdGn5x+X/y/0mG5MBMbZK/E5uZcQiZvXxVQ+gQTAdicO07ZuaulTMiEEsYlaP1wJgMTKrsSMDDN4VAzTAIIGguyvQAIMEgu6uQAMMEgi6uwINMEgg6O4KNMAggaC7K9AAgwSC7q5AAwwSCLq7Ag0wSCDo7go0wCCBoLsr0ACDBILurkADDBIIursCDTBIIOjuCjTAIIGguyvQAIMEgu6uQAMMEgi6uwINMEgg6O4KNMAggaC7K9AAgwSC7q5AAwwSCLq7Ag0wSCDo3qIC2YLK3t55+4WDQ5m4E49YxExtjZ04RE5aAGQg36Ri72oZMGBiEZPYVa3Fdld2oJ+XdkpD9wuPHfTsfuF5u9/Hxpn4tQDIq6CuSBekITvWJ8mNOJndsU7sqtYCIC+6OSq1WgMB1m15Zet/VWsBkHW26NuCqhLJ7LzFl0hmSmureS2A1R8fRmCuklMtgNW32o8AWCWn0gBZU1nvqi/eIwCSE7kVXfeLdqbkeMkOz3rvpO7XAMf/ad0LKMiJ3MixmJUGyMsN70m8B4spw7pT/deAYqSMWUYuDyRyI8diVhogd/ixRMIcsSqL91LXg/52a9+iWpMTOdpMwARMwAQKEPgDggyFYmLX3eIAAAAASUVORK5CYII=);
background-repeat: no-repeat;
background-position: right;
background-size: 20px;
padding-right: 20px;
}
.top .github a {
background-image: url(data:image/png;base64,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);
background-repeat: no-repeat;
background-position: right;
background-size: 24px;
padding-right: 24px;
}
.top .linkedin a {
background-image: url(data:image/png;base64,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);
background-repeat: no-repeat;
background-position: left 0%;
background-size: 17px;
padding-left: 21px;
}
.top .email a {
background-image: url(data:image/png;base64,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);
background-repeat: no-repeat;
background-position: left 300%;
background-size: 18px;
padding-left: 20px;
}
.top .twitter a {
background-image: url(data:image/png;base64,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dxTj1s3FkIlMEe04p72ybGRXWy4FbU2xIIVtK1MV25oUtp3SV4iT0/OOFMTV41FMS0Huen5kcmnInSlkG05LRToIECBAgAABAgQIECBAgAABAgQIECBQKwKr08pkn7iiO85bVqiVLusngbILCNamQXrbrlLcdE9/jIxO4yKnnlAgC9paU5DWkZaO7Err8/amfdqWdzenoO3o/myr07+A6G1tiuY6ydpG09KQT7w4Fnc+MhB3PzYYRwbSGw4CBAgQIECAAAECBAgQIECAAAECBAjUgMAZKwvxV9f0xIq0EpmDQKMKCNamMfO3pzBk073F6BeGTENteqdmAVohBW2dLc0pbGuKnlTVtrgrP1nRtjaFbFngtrSjObJArlaPiVSo9mxxLH6eqta+l75TT72QloaUr9XqdOo3AQIECBAgQIAAAQIECBAgQIAAgYYROH91S3z++r5ozTfMkA2UwBsEBGtvIHnzN374+GBsSMHaCy+PvflJPim7QCH9R7o9bcTWmYK2rKptQQrWlqV/EXFSWjbypJ7sMR+L0pKS+RoL2/rT0pAPvzASdz0yGNufGIrB9NpBgAABAgQIECBAgAABAgQIECBAgACBahTIpSK1t69ri8+kirU6WWCsGpn1qQYEBGvTmKR/eXI4Nmzuj30HrQU5Dbayn5pVq7Xkm1LY1hztKWzLArfethS2dediZRa0TYZtuVjckYtClYdt2dKQTx8Zi7v3DsYPHhmKAy/6bpX9C6NBAgQIECBAgAABAgQIECBAgAABAgRmLdDW0hTXndUef7q+a9ZtaYBALQsI1qYxe9ufGY6NW4uxe//INK5y6lwIZGFb4ZWwLf0HPltGMgvblqbKthWpsu3kFLatSo8rU/hWjceLgxOx68BI3JGWhty1bzjt46d6rRrnSZ8IECBAgAABAgQIECBAgAABAgQINKpATypk+M0L2uNDF3Q0KoFxE5gUEKxN44vw8PMjsWFbKe5Py/Y5ql+g+VhlW1sqW2s/FrYt6kx7t6XXizvT3m2duVhy7GdpV3N0pr3dsj3e5usYTiuMPvniWPzo8YH46WNDcTBVsjkIECBAgAABAgQIECBAgAABAgQIECBQDQJLUvHC713aGTec1lYN3dEHAvMmIFibBv3el8YmK9bueWxwGlc5tZoEssq25pSetaR921rTpmwtKUxrK6Tn6bErLS25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x8qtaKf3GAQIECBAgAABAgQIECAQUSxEvOWyUvzhfTNx0cQwEgIECBAgQOAlAcGanwIBAgQI5FIgO5utls5mmw/aUkXbruOteP5AM55PQdumFLTNVduRvccgQIAAAQIECBAgQIBA3gSGU4521eqR+OP3zsSl04VQq5a3X4D1EiBAgMDrCQjWXk/HawQIECCQG4Gsoq3+UtBWfamibcOhZrywvx6bUuB26ERr/vy23IBYKAECBAgQIECAAAECuRQYTinampXF+OyDK+KaVYXIHhsECBAgQIDAjwUEaz+2cI8AAQIECLwscGrryHp6cLQSselII9bvb8TGA43YdaQVtbqStpfB3CFAgAABAgQIECBAoO8FhlKItnqmEJ95cCZuTBVrQrW+31ILIECAAIFFEBCsLQKqSxIgQIDA4AlkbSFTx8hopKq2rIVkudGJbUdbselQI7YfbcaOw63Yn9pJ1tPzBgECBAgQIECAAAECBPpR4MLU9vGTD0zHLZeUouBYtX7cQnMmQIAAgSUQEKwtAbKvIECAAIHBE8jis4X2kQvVbVngtn+2HVtT4LbtcArbjqbKtsPtmK225t87eApWRIAAAQIECBAgQIDAoAismirE7987HbdfJlQblD21DgIECBBYHAHB2uK4uioBAgQI5FQgq2xrtLLqts7JCrd0e7TSiZ3Hs6CtGbtSVdve7O9YK+aq7WinKjiDAAECBAgQIECAAAECyykwM3EyVLvrilIUVaot51b4bgIECBDoAwHBWh9skikSIECAQH8LZGFbVtWWhW2pqG0+cMvuz6a2kVnItiOFbLvS357jjdh3rB1H5lrRTOGcQYAAAQIECBAgQIAAgcUWmBofjv/z7qm478qxGCks9re5PgECBAgQ6H8BwVr/76EVECBAgECfCnSywG0+aEuBWxa8zQdwJ89wOzTXjr2zqbIttZbcd6IVB9L9A+k2C93qjYjsswYBAgQIECBAgAABAgTOR2BybCg+fOd0vO/asSgJ1c6H0mcJECBAIEcCgrUcbbalEiBAgEB/CGSZ2XzoNh+2debbRb4cwKUXjlUi9mWhWwrZssDtcLkdx1NbyexvNrWdPJFuGymlE771x36bJQECBAgQIECAAIHlEJgYHYoP3TYV//It4zEqVFuOLfCdBAgQINCnAoK1Pt040yZAgACB/ApkrSVPtpc82Vpy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);
background-repeat: no-repeat;
background-position: left 50%;
background-size: 18px;
padding-left: 22px;
}
.pagedjs_sheet {
padding: 5px;
background-image: linear-gradient(to bottom, rgba(255, 255, 255, 1) 0%, rgba(255, 255, 255, 1)), linear-gradient(to bottom, #00A3E2 0%, #ecff00 100%);
background-clip: content-box, padding-box;
}

h3 ~ p {
padding-bottom: 4px;
}

p:has(> br) {
padding: 0;
}

h2 ~ center ~ ul:not(.os) {
padding-top: 4px;
}
p {
margin: 0;
line-height: 12px;
}
.footnote-ref {
color: red;
}
.footnotes > ol {
margin: 0;
padding: 0;
list-style-position: inside;
}
.footnotes > ol > li > p {
display: inline;
}
.footnotes > hr {
margin: 0;
border: none;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnote-break {
width: 1in;
}
sup {
vertical-align: top;
}
ul {
margin: 0;
}
ul.os {
padding-left: 0;
list-style-type: none;
line-height: 1.45;
}
ul.os > li {
padding: 0 0 0 24.5px;
background-position: 0% 55%;
background-size: 18px;
background-repeat: no-repeat;
}
ul > li.content {
padding: 0;
list-style-position: inside !important;
}
ul:not(.os) {
padding: 0 0 0 14px;
}
ul:not(.os) > li::marker {
content: '– ';
}
li.li-earth::marker {
content: '🌎';
}
li.li-sat::marker {
content: '🛰';
}
li.li-dish::marker {
content: '📡';
}
li.li-rocket::marker {
content: '🚀';
}
li.li-map::marker {
content: '🗺';
}
li.li-mac::marker {
content: '💻';
}
div.booz > h3::after {
content: '(February 2023 – Current)';
}
div.peraton > h3::after {
content: '(June 2017 – December 2022)';
}
div.jpmc h3::after {
content: '(June 2016 – August 2016)';
}
div.psu h3::after {
content: '(January 2016 – October 2016)';
}
:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}


.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}

}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">
h1 {
text-align: center;
color: #00A3E2;
font-size: 30px;
font-family: Garamond;
font-weight: unset;
margin: unset;
}
h2 {
text-align: center;
text-decoration: underline;
font-size: 16.5px;
font-family: 'Century Gothic';
font-weight: unset;
margin: 0px 0px 4px 0px;
}
h3 {
font-size: 16.5px;
font-family: 'Century Gothic';
font-weight: unset;
margin: 0px 0px 4px 0px;
}
h3::after {
float: right;
margin: 0 20px 0 0px;
font-size: 10px;
padding-top: 4px;
font-weight: bold;
font-style: italic;
}
.top {
font-size: 15px;


}
body {
font-family: 'Helvetica Neue';
font-weight: 200;
}

blockquote {
font-family: 'Old Standard TT', Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'STKaiti', 'KaiTi', '楷体', 'SimKai', 'DFKai-SB', 'NSimSun', serif;
}
code {
font-family: Consolas, Courier, "Courier New", 'STKaiti', 'KaiTi', 'SimKai', monospace;
}
pre, code {
font-size: .95em;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<!--<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Vincent Clemson’s Rèsumè</h1>
</div>
</div>-->

<div class="front-matter-container">
</div>

<div class="main">
<div class="footer">
🇺🇦made with <a href="https://github.com/rstudio/pagedown">{pagedown}</a> &amp; <a href="https://pagedjs.org">Paged.js</a> &amp; ❤️
</div>
<div id="vincent-clemson" class="section level1">
<h1>Vincent Clemson</h1>
<div class="top">
<div class="cell">
<a href="tel:1-570-269-0242" target="_blank">+1 570-269-0242</a>
</div>
<div class="site">
<a href="https://prncevince.github.io" target="_blank">🖥 prncevince.github.io</a>
</div>
<div class="email">
<a href="mailto:vincent.clemson@gmail.com" target="_blank">vincent.clemson@gmail.com</a>
</div>
<div class="github">
<a href="https://github.com/prncevince" target="_blank">github.com/prncevince</a>
</div>
<div class="linkedin">
<a href="https://linkedin.com/in/vincentclemson" target="_blank">linkedin.com/in/vincentclemson</a>
</div>
<div class="twitter">
<a href="https://twitter.com/prncevincecares" target="_blank">twitter.com/prncevincecares</a>
</div>
</div>
<p><br></p>
<div id="education" class="section level2 education">
<h2>Education</h2>
<center>
The Pennsylvania State University 2017 - B.S in Mathematics | Minor in Statistics
</center>
<p><br></p>
</div>
<div id="background" class="section level2">
<h2>Background</h2>
<center>
👋Hi I’m Vince, a data scientist. Currently, I’m analyzing NATO<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> OOI<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> object detectors using commercial satellite imagery on my AI Edge Kit team &amp; human biometric performance data for JSOC<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>. Previously, I worked on a GEOINT<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a> performance modeling team for 5 years, where I <a href="https://github.com/prncevince" target="_blank"><code>wrote code</code></a> to analyze large amounts of transactional data on geospatial imagery (billions of records) for the NGA<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a> to help improve the NSG<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a>. On my team, I promoted open source software development best practices and data science tooling usage in Python &amp; R. I managed my team’s government network GitLab &amp; corporate GitHub organizations, which grew from 0 to 300+ repositories over my tenure. When I’m not traveling or salsa dancing, I’m working remotely. 🕺🧑‍💻
</center>
<p><br></p>
</div>
<div id="what-im-interested-in-doing" class="section level2">
<h2>What I’m interested in doing</h2>
<center>
Applying my skills in data science, visualization, machine learning, &amp; spatial analytics to drive insight as a contributing member of an analytics team who uses similar <a href="https://github.com/prncevince" target="_blank">open source</a> tooling to analyze their data
</center>
<p><br></p>
</div>
<div id="open-source-projects" class="section level2">
<h2>Open Source Projects</h2>
<ul class="os">
<li class="content li-earth">
Built <a href="https://prncevince.github.io/spatial-mlr3-playground" target="_blank">Spatial Machine Learning</a> Models using {mlr3} to run within GitHub Actions
</li>
<li style="background-image: url(&#39;./assets/img/dlwpt-transparent.png&#39;);">
Rebuilt Tomas Beuzen’s <a href="https://prncevince.github.io/deep-learning-with-pytorch" target="_blank">Deep Learning with PyTorch</a> &amp; ported it to render w/ nbdev &amp; Quarto
</li>
<li class="content li-sat">
Developed &amp; Deployed analytic Dash &amp; {shiny} web apps for NGA mission analysts to predict years of geospatial coverage of Earth Observation <a href="https://huggingface.co/spaces/prncevince/sat-viz" target="_blank">Satellite Systems</a>
</li>
<li style="background-image: url(&#39;./assets/img/git.png&#39;);">
Improved dev &amp; data science workflows by teaching engineers to version control their code <a href="https://prncevince.github.io/using-git" target="_blank">using Git</a>
</li>
<li style="background-image: url(&#39;./assets/img/quarto.png&#39;);">
Created <a href="https://github.com/prncevince/quarto-shims" target="_blank">Quarto</a>, <a href="https://github.com/prncevince/r-shims" target="_blank">R &amp; RStudio CLI utility shims</a> to handle multiple Quarto/R installations
</li>
<li style="background-image: url(&#39;./assets/img/leaflet.png&#39;);">
Started developing an R package, <a href="https://prncevince.github.io/leaflet.super/" target="_blank">{leaflet.super}</a>, to visualize big geospatial data with Leaflet
</li>
<li style="background-image: url(&#39;./assets/img/ghactions.png&#39;);">
<a href="https://github.com/prncevince/r-actions/" target="_blank">Built R language GitHub Actions</a> to run R environments remotely &amp; <a href="https://github.com/actions/cache/pull/826" target="_blank">contributed back</a> to GitHub
</li>
<li class="content li-dish">
My old team had massive amounts of imagery analyst user activity data, and we constantly found out what’s
important to the analysts, so I built exploratory <a href="https://prncevince.github.io/pca-mlr3-pipelines" target="_blank">unsupervised clustering tools</a> to help us do so
</li>
<li class="content li-rocket">
Military wartime border region behavior is of interest within the geospatial intelligence domain, so I built tools for analyzing
satellite image <a href="https://github.com/prncevince/borders" target="_blank">distance to border regions</a> &amp; for creating <a href="https://github.com/prncevince/rspatial-borders-examples" target="_blank">new geometric border regions</a>
</li>
<li class="content li-map">
Quantifying size &amp; types of collections (e.g different camera sensor modes) is critical in Earth observation satellite systems engineering, so I’ve built different analytical product mapping tools to help do so:<br>
e.g. <a href="https://github.com/prncevince/animation-stat-plotly" target="_blank">advanced Plotly map animations</a> &amp; interactive <a href="https://github.com/prncevince/leaflet-plotly" target="_blank">Leaflet htmlwidget heatmaps</a>
</li>
<li style="background-image: url(&#39;./assets/img/webpack.png&#39;);">
Once worked my way through the entire <a href="https://github.com/prncevince/webpack-guide" target="_blank">Webpack Guide</a> &amp; made a Git tag for each chapter
</li>
<li class="content li-mac">
I version control my <a href="https://github.com/prncevince/my-prof" target="_blank">MacOS dot-profile</a> &amp; config files for rapid dev/data-sci setup
</li>
</ul>
<p><br></p>
</div>
<div id="programming-skills" class="section level2">
<h2>Programming Skills</h2>
<center>
I have hands on expertise in using various Machine Learning, Data Analysis, Geospatial &amp; Visualization Packages, Web Technologies (app frameworks &amp; scraping tools), SSGs (static site generators),<br>
&amp; Notebook / Computational Medium tools.<br>
Below is a non-exhaustive high level list of the technologies that I’m working in.<br>
Python, Conda/Mamba, Jupyter, nbdev, Sphynx, Cookiecutter, SQL, JavaScript, Bash, Zsh, tmux, VSCode, R, Quarto, R Markdown, GNU Make, asciinema, Leafmap, Google Earth Engine, QGIS, GDAL
</center>
</div>
<div id="career-path" class="section level2 page-break-before">
<h2>Career Path</h2>
<div id="ai-engineer-booz-allen-hamilton" class="section level3 booz">
<h3>AI Engineer – Booz Allen Hamilton</h3>
<ul>
<li>Conducted a statistical performance analysis for evaluating 3rd party geospatial computer vision algorithms 🛩🏘️<br>
(e.g. <a href="https://www.cosmiqworks.org/rareplanes/">aircraft</a> &amp; <a href="https://spacenet.ai">building</a> detectors using Maxar satellite imagery, <a href="https://www.pola.rs">polars</a>, <a href="https://r-spatial.github.io/sf/">{sf}</a>, <a href="https://github.com/rspatial/terra#readme">{terra}</a>, &amp; <a href="https://quarto.org">Quarto</a> to document results)</li>
<li>Building interactive satellite imagery data lakes (e.g. using <a href="https://leafmap.org/#demo">Leafmap</a>, <a href="https://developmentseed.org/titiler/">TiTiler</a>, &amp; STAC<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a>)</li>
<li>Built reproducible, interactive statistical reports on soldier biometric performance data w/ {flexdashboard}</li>
</ul>
</div>
<div id="systems-engineer---peraton" class="section level3 peraton">
<h3>Systems Engineer - Peraton</h3>
<p>Data science on the NGA’s enterprise systems engineering contract</p>
<ul>
<li>Analyzed the metadata &amp; transactions of all Geospatial Intelligence imagery products across the IC</li>
<li>Wrangled large amounts of historical categorical, numerical, spatial, &amp; temporal data using extremely efficient in/out of memory tools (e.g. data.table, Apache Arrow, &amp; Parquet file data lakes)</li>
<li>Prototyped, developed, &amp; maintained modeling tools to conduct EDA on data to analyze patterns and trends (e.g. ggplot2, sf, Plotly, Matplotlib, Leaflet, Dash, Shiny, Docker, &amp; Cloud Foundry)</li>
<li>Performed spatial relational/geometric operations on datasets to enrich feature sets (e.g. border regions)</li>
<li>Used reproducible computational mediums to conduct workflows (e.g. R Markdown, Jupyter notebook)</li>
<li>Statistical analysis on the performance, sizing, &amp; budgeting of NSG imagery &amp; their driving relationships<br>
(e.g. linear trend models, bandwidth models, human-in-the-loop supervised/unsupervised EDA ML workflows)</li>
<li>Statistical analysis &amp; Orbital Mechanics analyses on the performance of an ABI<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a> satellite / ground sensor system</li>
<li>Worked on a distributed team &amp; operated in a cloud computing environment. Experience with building a cloud from the ground up, config management, &amp; permissions (e.g. AWS, RStudio Server Pro, Unix/Linux, VPC)</li>
</ul>
</div>
<div id="application-developer-intern---jp-morgan-chase" class="section level3 jpmc">
<h3>Application Developer Intern - JP Morgan Chase</h3>
<ul>
<li>Agile development team in JP’s Technology Analyst Program. Team of 6 interns built a full stack Java-Spring tool aggregating data for the planning &amp; execution of the migration &amp; decommissioning of legacy JPMC data center servers. Worked front &amp; backend. Led role as Scrum Master.</li>
</ul>
</div>
<div id="data-analytics-intern---img-learfield-penn-state-athletics" class="section level3 psu">
<h3>Data Analytics Intern - IMG Learfield &amp; Penn State Athletics</h3>
<p>Season Ticket Holder Survey Analysis</p>
<ul>
<li>Performed Decision Tree Modelling in R for finding trends between customers and ticket sale renewals</li>
<li>Mined customer survey data using NLP<a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a> techniques &amp; the NLTK<a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a> in Python (e.g. tokenizers, collocations)</li>
</ul>
<p><br></p>
</div>
</div>
<div id="machine-learning-skills" class="section level2">
<h2>Machine Learning Skills</h2>
<center>
Some topics I’ve dived into while integrating machine learning workflows onto NSG transactional log data.<br>
Spatial Cross-Validation Techniques, Discrete Event Simulation, Generalized Linear Models, Ensemble Models, Unsupervised Learning, Principal Components Analysis, Clustering Techniques,<br>
Dimensionality Reduction (Feature Selection)
</center>
<center>
Other topics I’ve dived into through various ML workings. e.g. rebuilding <a href="https://prncevince.github.io/deep-learning-with-pytorch" target="_blank">Deep Learning with PyTorch</a>.<br>
CNNs (Convolutional Neural Networks), GANs (Generative Adversarial Networks), Gradient Descent, Regularization, Decision Boundary, One-vs-All Multiclass Classification, Neural Networks, Vectorization,<br>
Backpropagation and Advanced Optimization techniques
</center>
</div>
</div>
<div class="footnotes footnotes-end-of-document">
<hr />
<ol>
<li id="fn1"><p> NATO - North Atlantic Treaty Organization<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p> OOI - Object of Interest<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p> JSOC - Joint Special Operations Command<a href="#fnref3" class="footnote-back">↩︎</a></p></li>
<li id="fn4"><p> GEOINT - Geospatial Intelligence<a href="#fnref4" class="footnote-back">↩︎</a></p></li>
<li id="fn5"><p> NGA - National Geospatial-Intelligence Agency<a href="#fnref5" class="footnote-back">↩︎</a></p></li>
<li id="fn6"><p> NSG - National System for Geospatial-Intelligence<a href="#fnref6" class="footnote-back">↩︎</a></p></li>
<li id="fn7"><p> STAC - SpatioTemporal Asset Catalogs<a href="#fnref7" class="footnote-back">↩︎</a></p></li>
<li id="fn8"><p> ABI - Activity Based Intelligence<a href="#fnref8" class="footnote-back">↩︎</a></p></li>
<li id="fn9"><p> NLP - Natural Language Processing<a href="#fnref9" class="footnote-back">↩︎</a></p></li>
<li id="fn10"><p>NLTK - Natural Language Toolkit<a href="#fnref10" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
<div class="page2-end">
<p><a href="https://github.com/prncevince/borders" target="_blank">
<img src="data:image/png;base64,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">
</a></p>
</div>
</div>


<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
<script>
  window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); };
</script>
<script defer src="/_vercel/insights/script.js"></script>
</body>
</html>
